## 乐购商城开发文档

## 分布式基础概念

**1. 微服务**

拒绝大型单体应用，基于业务进行服务微化拆分，各个服务独立部署运行。

**2. 分布式，集群，节点**

分布式中的每一个节点，都可以做集群。
集群并不一定是分布式的。
节点是集群中的一个服务器。

**3. 远程调用**

HTTP + JSON

**4. 负载均衡**

- **轮询**：请求依次选择服务器，直至最后一台服务器，然后循环。
- **最小连接**：优先选择连接数最少即压力最小的服务器。
- **散列**：根据请求源的IP的散列来选择服务器。

**5. 服务注册与发现中心**

**6. 配置中心**

集中管理微服务的配置信息

**7. 服务熔断，服务降级**

- **服务熔断**：设置服务的超时，当被调用的服务经常失败到达某个阈值，可以开启断路保护机制，后来的请求不再去调用该服务。本地直接返回默认的数据。
- **服务降级**：运维期间，当系统处于高峰期，系统资源紧张，可以让非核心的业务降级运行。

**降级**：某些服务不处理或者简单处理（抛异常、返回NULL、调用Mock数据、调用Fallback处理逻辑）

**8. API 网关**

抽象微服务中都需要的公共功能，提供客户端负载均衡，服务自动熔断，灰度发布，统一认证，限流流控，日志统计等丰富的功能。

## 1. 项目简介

**乐购商城是一套完善的微服务电商系统，由前台商城系统和后台管理系统构成，基于SpringBoot、SpringCloud、SpringCloud alibaba、Vue实现，采用前后端分离开发模式。前台商城系统具有首页门户、商品推荐、商品检索、商品详情、用户中心、购物车、订单流程、支付、秒杀等功能，后台管理系统具有控制面板、统计管理、商品系统、用户系统、订单系统、库存系统、优惠系统、内容管理、系统管理等模块。**

涵盖**Restful接口**、**数据校验**、**网关**、**注册发现**、**配置中心**、**熔断**、**限流**、**降级**、**链路追踪**、**性能监控**、**压力测试**、**系统预警**、**集群部署**、**持续集成**、**持续部署等技术点**，均采用当前最流行的技术栈。

### 1.1 项目架构

#### 1.1.1 系统架构图

![](E:\程序人生\个人学习笔记\学习笔记图床\乐购商城微服务架构图.jpg)

#### 1.1.2 服务划分图

![](E:\程序人生\个人学习笔记\学习笔记图床\服务划分图.png)



![](E:\程序人生\个人学习笔记\学习笔记图床\乐购服务划分图.png)

#### 1.1.3 模块说明

```
|-- tesco
    |-- tesco-admin -- 后台管理系统后端
    |-- tesco-admin-vue -- 后台管理系统前端
    |-- tesco-api -- 各个微服务的API接口
    |   |-- tesco-cart-api
    |   |-- tesco-coupon-api
    |   |-- tesco-goods-api
    |   |-- tesco-order-api
    |   |-- tesco-search-api
    |   |-- tesco-seckill-api
    |   |-- tesco-third-api
    |   |-- tesco-user-api
    |   |-- tesco-ware-api
    |-- tesco-cart -- 购物车微服务
    |-- tesco-common -- 通用工具类
    |-- tesco-coupon -- 优惠微服务
    |-- tesco-database -- 数据库表
    |-- tesco-dependency -- 核心依赖包
    |-- tesco-gateway -- 网关微服务（分为管理员、用户、游客三个急别）
    |   |-- tesco-gateway-system
    |   |-- tesco-gateway-user
    |   |-- tesco-gateway-web
    |-- tesco-goods -- 商品微服务
    |-- tesco-oauth2 -- 认证微服务
    |-- tesco-order -- 订单微服务
    |-- tesco-search -- 检索微服务
    |-- tesco-seckill -- 秒杀微服务
    |-- tesco-third-services -- 第三方接口服务
    |-- tesco-user -- 用户微服务
    |-- tesco-ware -- 库存微服务
```

### 1.2 技术选型

#### 1.2.1 后端技术

| 技术                          | 说明                           |
| ----------------------------- | ------------------------------ |
| Spring Boot                   | 容器+MVC框架                   |
| MyBatis                       | ORM框架                        |
| MyBatis Plus                  | MyBatis增强工具                |
| MySql                         | 数据库                         |
| Redis                         | 分布式缓存                     |
| RabbitMQ                      | 消息中间件                     |
| Elasticsearch                 | 搜索引擎                       |
| Kibana                        | Elasticsearch可视化工具        |
| LogStash                      | 日志收集工具                   |
| Redisson                      | 分布式锁框架                   |
| SpringCache                   | 简化分布式缓存开发             |
| JSR303                        | 数据校验                       |
| Lombok                        | 简化对象封装工具               |
| Nginx                         | 反向代理、限流、负载均衡、容错 |
| Docker                        | 虚拟化容器技术                 |
| Kubernetes                    | 容器管理、集群部署             |
| Jenkins                       | 持续集成                       |
| AlipayTemplate                | 支付宝支付                     |
| Spring Cloud Gateway          | API 网关                       |
| Spring Cloud Security+Oauth2  | 安全认证授权、第三方登录       |
| Spring Cloud OpenFeign        | 服务消费（远程调用）           |
| Spring Cloud Ribbon           | 服务消费（负载均衡）           |
| Spring Cloud Sleuth+Zipkin    | 分布式链路追踪及可视化         |
| Spring Cloud Alibaba Nacos    | 服务发现与注册、分布式配置中心 |
| Spring Cloud Alibaba Sentinel | 服务容错（限流、熔断、降级）   |
| Spring Cloud Alibaba OSS      | 阿里云对象存储服务             |
| Spring Cloud Alibaba Seata    | 分布式事务解决方案             |
| Spring Cloud Alibaba SMS      | 短信服务                       |

#### 1.2.2 前端技术

| 技术         | 说明               |
| ------------ | ------------------ |
| Vue          | 前端框架           |
| Vue-router   | 路由管理器         |
| Element UI   | 前端UI框架         |
| Axios        | 前端HTTP框架       |
| V-Charts     | 前端图表框架       |
| HTML CSS JS  | 前端技术           |
| ECMAScript 6 | JavaScript语言标准 |
| JQuery       | JS插件库           |
| Thymeleaf    | 模板引擎           |

### 1.3 开发环境

| 工具                          | 版本号   |
| ----------------------------- | -------- |
| JDK                           | 1.8      |
| MySql                         | 5.7.22   |
| Redis                         | 5.0      |
| RabbitMQ                      | 3.8.2    |
| Elasticsearch                 | 7.4.2    |
| Kibana                        | 7.4.2    |
| LogStash                      | 7.4.2    |
| Nginx                         | 1.17.10  |
| Docker                        | 19.03.05 |
| Zipkin                        | 2.22.2   |
| Spring Cloud Alibaba Nacos    | 1.1.14   |
| Spring Cloud Alibaba Sentinel | 1.8.0    |
| Spring Cloud Alibaba Seata    | 0.9.0    |

### 1.4 开发工具

| 工具         | 说明              |
| ------------ | ----------------- |
| IDEA         | Java代码编译环境  |
| VsCode       | 前端代码编辑器    |
| VMware       | 虚拟机管理        |
| Navicat      | 数据库可视化工具  |
| RedisManager | 缓存可视化工具    |
| Postman      | 接口调试工具      |
| Xshell       | Linux远程连接工具 |
| Xftp         | 数据传输工具      |
| SwitchHosts  | 本地Host管理      |
| ApacheJMeter | 压力测试工具      |
| 花生壳       | 内网穿透工具      |
| Notepad      | 好用的记事本      |

## 2. 正式进入开发

### 2.1 基础篇开发（后台管理系统）

- **2.1.1 基于 Docker安装 Mysql、Redis、Nacos**
- **2.1.2 整合OSS阿里云对象存储**
- **2.1.3 JSR303数据校验**

```
 *   1）、给Bean添加校验注解:javax.validation.constraints，并定义自己的message提示
 *   2)、开启校验功能@Valid
 *      效果：校验错误以后会有默认的响应；
 *   3）、给校验的bean后紧跟一个BindingResult，就可以获取到校验的结果
 *   4）、分组校验（多场景的复杂校验）
 *         1)、	@NotBlank(message = "品牌名必须提交",groups = {AddGroup.class,UpdateGroup.class})
 *          给校验注解标注什么情况需要进行校验
 *         2）、@Validated({AddGroup.class})
 *         3)、默认没有指定分组的校验注解@NotBlank，在分组校验情况@Validated({AddGroup.class})下不生效，只会在@Validated生效；
 *
 *   5）、自定义校验
 *      1）、编写一个自定义的校验注解
 *      2）、编写一个自定义的校验器 ConstraintValidator
 *      3）、关联自定义的校验器和自定义的校验注解
 *      @Documented
 *      @Constraint(validatedBy = { ListValueConstraintValidator.class【可以指定多个不同的校验器，适配不同类型的校验】 })
 *      @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
 *      @Retention(RUNTIME)
 *      public @interface ListValue {}
```

### 2.2 高级篇开发

#### 2.2.1 ES+Kibana

- **部署 ES**

```
docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \
-e "discovery.type=single-node" \
-e ES_JAVA_OPTS="-Xms64m -Xmx512m" \
-v /usr/local/docker/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \
-v /usr/local/docker/elasticsearch/data:/usr/share/elasticsearch/data \
-v /usr/local/docker/elasticsearch/plugins:/usr/share/elasticsearch/plugins \
-d elasticsearch:7.4.2
```

设置elasticsearch目录的权限

```
chmod -R 777 /usr/local/docker/elasticsearch/
```

- **部署 Kibana**

```
docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.75.154:9200 -p 5601:5601 -d kibana:7.4.2
```

- **IK分词器**

```
# 安装
wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.4.2/elasticsearch-analysis-ik-7.4.2.zip

# 解压
unzip elasticsearch-analysis-ik-7.4.2.zip

rm -fr elasticsearch-analysis-ik-7.4.2.zip
```

#### 2.2.2 Nginx

```
# 提前创建好目录结构
mkdir /usr/local/docker/nginx/conf -p
mkdir /usr/local/docker/nginx/html
mkdir /usr/local/docker/nginx/logs

# 启动一个nginx示例（只为复制出配置）
docker run -p 80:80 --name nginx -d nginx

# 拷贝容器内的配置文件到当前目录（/usr/local/docker/nginx/conf）
docker container cp nginx:/etc/nginx .

#优化目录结构
mv * ../
rm -fr nginx

# 删除原容器
docker rm -f nginx

# 创建新的容器
docker run -p 80:80 --name nginx \
-v /usr/local/docker/nginx/html:/usr/share/nginx/html \
-v /usr/local/docker/nginx/logs:/var/log/nginx \
-v /usr/local/docker/nginx/conf:/etc/nginx \
-d nginx
```

- **反向代理**
- **负载均衡**
- **坑**

**nginx代理给网关时，会丢失请求的host信息**

解决方法：

```
proxy_set_header Host $host
```

#### 2.2.3 性能

**性能考虑点：**

数据库、应用程序、中间件（tomcat、nginx）、网络和操作系统等方面 **CPU密集型**
**IO密集型**

**JMeter使用过程中出现的一些问题（略）**

**一丶监控**

1. jvm内存模型（以后单独学习）
2. 堆内存与垃圾回收
3. jvisualvm使用 （注意使用与java版本匹配的地址）

**二丶优化**

- **中间件**

中间件越多，性能损失越大，大多都损失在网络交互上 。

解决方案：优化中间件，提高中间件的吞吐量；提高传输效率（网卡，网线，传输协议，传输技术等）

- **业务（优化重点）**

数据库 模板渲染速度 静态资源

解决方案：优化Mysql，为字段添加索引，降低日志级别；开启模板引擎的缓存

- **Nginx动静分离**

1. 将所有项目的静态资源都放在Nginx中
2. 规则：/static/**所有请求都由Nginx直接返回

- **线上应用内存奔溃宕机情况**

#### 2.2.4 缓存

##### 一丶本地缓存（不适用分布式场景）

问题：

1. 分布式场景下，同一服务的不同服务器，要分别进行缓存；
2. 数据发生修改时，同一服务的不同服务器，会出现数据不统一的情况。

##### 二丶分布式缓存（集中式的缓存中间件）

**Redis缓存**

1. 缓存中存储的数据都是Json字符串
2. Json跨语言、跨平台兼容
3. 序列化与反序列化（往Json中放字符串，拿出的字符串，需要逆转成所需的对象类型）

**高并发下缓存失效问题**

- **穿透**

高并发查询不存在的数据，数据库瞬时压力增大，导致崩溃。

解决方案：缓存null结果，并加入短暂过期时间。

- **雪崩**

缓存的数据大面积同时失效的时候迎来高并发。

解决方案：失效时间增加随机值，降低缓存过期时间的重复率。

- **击穿**

某一个高频热点数据失效的时候迎来高并发。

解决方案：加锁，只让一个人去查数据库，其他人等待查缓存。

**如何更好的实现加锁**

- **本地锁**

只能锁住当前进程，无法锁住所有

单体应用加锁后仍查询多次数据库的原因：

线程1查询数据库 -> 线程1释放锁 -> 线程2占用锁 -> 线程2确认无缓存 -> 线程2查询数据库 -> 线程1将数据放入缓存

（通俗说，线程1还没来得及放缓存，线程2已经进行了查询）

解决方案：

先将数据放入缓存，再释放锁。

- **分布式锁**

**常见问题及解决方法：**

1. 死锁 ---> 设置锁的自动过期时间
2. 业务超时，误删其他业务锁 ---> 设置uuid

lua脚本解锁（原子操作）

**加锁，解锁都要保证操作的原子性**

##### 三丶分布式锁框架 - Redisson

- **lock锁（阻塞式等待）**

特点：

1. 业务超时，运行期间，锁自动续期，默认30s（看门狗原理）
2. 业务运行完成，无需手动解锁，30s后自动删除

```
lock.lock();    //可以自动续期（看门狗的时间/3=10s）

lock.lock(10, TimeUnit.SECONDS);    //不能自动续期，自动解锁时间一定要大于业务运行时间

boolean res = lock.tryLock(100, 10, TimeUnit.SECONDS);  //尝试加锁，最多等待100秒，上锁以后10秒自动解锁

fairLock.lock(10, TimeUnit.SECONDS);    //公平锁
```

推荐使用 明确指定超时时间 的方法，但超时时间不能太小

- **读写锁**

```
RReadWriteLock rwlock = redisson.getReadWriteLock("anyRWLock");
// 最常见的使用方法
rwlock.readLock().lock();
// 或
rwlock.writeLock().lock();
```

**读数据加读锁（共享锁），改数据加写锁（互斥锁、独享锁）**

读+读：相当于无锁，并发读
写+读：等待写锁释放
写+写：阻塞方式
读+写：有读锁，写需要等待

**总：只要有写锁的存在，都需要等待**

- **信号量**

**可以用作分布式限流**

```
RSemaphore semaphore = redisson.getSemaphore("semaphore");
semaphore.acquire();    //获取一个信号（车位）
semaphore.acquireAsync();
semaphore.acquire(23);
semaphore.tryAcquire(); //尝试获取
semaphore.tryAcquireAsync();
semaphore.tryAcquire(23, TimeUnit.SECONDS);
semaphore.tryAcquireAsync(23, TimeUnit.SECONDS);

semaphore.release(10);
semaphore.release();    //释放一个信号（车位）
semaphore.releaseAsync();
```

场景：停车

- **闭锁**

```
RCountDownLatch latch = redisson.getCountDownLatch("anyCountDownLatch");
latch.trySetCount(1);
latch.await();

// 在其他线程或其他JVM里
RCountDownLatch latch = redisson.getCountDownLatch("anyCountDownLatch");
latch.countDown();
```

场景：学校锁门（所有班级锁门，再锁大门）

##### 四丶缓存数据的一致性问题

- **双写模式**

更新数据库，同时更新缓存

- **失效模式**

更新数据库，删除缓存

问题：脏数据 解决方法：加锁 ---> 系统比较笨重

[缓存一致性]

[Canal]

##### 五丶SpringCache（简化缓存开发）

- **引入依赖**

```
    <!-- SpringCache -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-cache</artifactId>
    </dependency>
```

- **默认行为**

1. 如果缓存中有，不调用方法
2. key自动生成 ---> `缓存名称::SimpleKey []`
3. 缓存的value值，默认使用jdk序列化机制，将序列化后的数据保存到redis
4. 默认ttl=-1，即永不过期

- **自定义配置**

1. 指定缓存的key
2. 指定缓存的存活时间
3. 将数据保存为json

```
# 使用redis作为缓存
spring.cache.type=redis
# 存活时间（毫秒为单位，1小时）
spring.cache.redis.time-to-live=3600000
# 前缀，方便区分（若不指定前缀，默认使用缓存的名字作为前缀）
#spring.cache.redis.key-prefix=CACHE_
# 是否启用前缀
spring.cache.redis.use-key-prefix=true
# 是否缓存空值，防止缓存穿透
spring.cache.redis.cache-null-values=true
package com.jerusalem.goods.config;

import org.springframework.boot.autoconfigure.cache.CacheProperties;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.cache.RedisCacheConfiguration;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.RedisSerializationContext;
import org.springframework.data.redis.serializer.StringRedisSerializer;

/****
 * SpringCache - 自定义缓存配置
 * @Author: jerusalem
 * @Description: MyCacheConfig
 * @Date 2020/6/24 14:58
 *****/
@EnableConfigurationProperties(CacheProperties.class)       //开启与配置文件的绑定功能
@Configuration
@EnableCaching      //开启缓存
public class MyCacheConfig {

    @Bean
    RedisCacheConfiguration redisCacheConfiguration(CacheProperties cacheProperties){

        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();
        config = config.serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()));
        config = config.serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));

        CacheProperties.Redis redisProperties = cacheProperties.getRedis();
        /**
         * 引入配置文件中的配置信息
         */
        if (redisProperties.getTimeToLive() != null) {
            config = config.entryTtl(redisProperties.getTimeToLive());
        }
        if (redisProperties.getKeyPrefix() != null) {
            config = config.prefixKeysWith(redisProperties.getKeyPrefix());
        }
        if (!redisProperties.isCacheNullValues()) {
            config = config.disableCachingNullValues();
        }
        if (!redisProperties.isUseKeyPrefix()) {
            config = config.disableKeyPrefix();
        }
        return config;
    }
}
```

- **常用注解**

```
@Cacheable
将数据保存到缓存

@CacheEvict
将数据从缓存中删除

@CachePut
更新缓存（不影响方法执行）

@Caching
组合多个缓存操作

@CacheConfig
在类级别，共享缓存的相同配置
```

**原理与不足：**

- 读模式：

1. 穿透：查询null数据

解决方案：缓存空值

1. 击穿：大量并发查询一个正好过期的数据

解决方案：默认无加锁，只有查询的时候可加同步锁

1. 雪崩：大量的key同时过期

解决方案：加过期时间

- 写模式（缓存、数据库一致性问题）
  1）、读写加锁
  2）、引入Canal，监控数据库的更新
  3）、读多写少，直接去数据库查询

**总结：**

**常规数据（读多写少，即时性，一致性要求不高的数据）：适合使用SpringCache**

**特殊数据：特殊设计**

#### 2.2.5 SpringSession

##### Session共享问题解决-不同服务，子域session共享（整合redis存储session）

**核心原理：**

**装饰者模式**

**@EnableRedisHttpSession 导入RedisHttpSessionConfiguration配置**

1. 给容器添加了一个组件RedisIndexedSessionRepository -》redis操作session的增删改查
2. SessionRepositoryFilter ==》 Filter：session存储过滤器，每个请求都必须经过filter

- 创建时，自动从容器中获取到了SessionRepository
- 原始的request,response都被包装（SessionRepositoryRequestWrapper）
- 以后获取session（request。getSession）
- wrappedRequest.getSession();

自动延期：redis中的数据也是有过期时间的

#### 购物车需求分析

- 用户购物车

- 游客购物车

#### RabbitMq

```
docker run -d --name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 985adbf13062
```

### 2.3 集群篇开发

