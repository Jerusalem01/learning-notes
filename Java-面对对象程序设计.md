### Java - 面向对象程序设计

#### 1. 核心思想：万物皆对象

#### 2. 三大特性：

**封装**：将对象的“属性”和“行为”抽象出来包装到类中

**继承**：将具有相同“属性”和“行为”的对象抽象出来并包装成一个父类

**多态**：多种形态，相同的“属性”和“行为”，却有不同的表现形式

```
public abstract class Animail {

    private String color;
    private Integer age;
    private String sex;

    public abstract void call();

    public void run(){
        System.out.println("跑");
    }

    public void jump(){
        System.out.println("跳");
    }
}
public class Dog extends Animail {
    @Override
    public void call() {
        System.out.println("旺");
    }
}
public class Cat extends Animail {
    @Override
    public void call() {
        System.out.println("喵");
    }
}
```

#### 3. 面向接口编程：

**接口**是为了处理各个对象之间的协作关系，是系统设计的关键组成部分，主要作用是将“定义”与“实现”分离，从而实现系统“**解耦**”的目的。

#### 4. 面对对象设计原则：

1. 面向扩展开放，面向修改关闭
2. 接口隔离原则
3. 组合/聚合原则
4. 里氏替换原则
5. 最少知识原则（迪米特法则）
6. 单一职责原则
7. 依赖倒置原则

#### 5. Java EE

##### 5.1 Maven

- **生命周期**

| 名称     | 描述   |
| -------- | ------ |
| clean    | 清理   |
| validate | 验证   |
| compile  | 编译   |
| test     | 测试   |
| package  | 打包   |
| verify   | 再验证 |
| install  | 安装   |
| site     |        |
| deploy   | 部署   |

- **插件**

| 名称      | 描述 |
| --------- | ---- |
| clean     |      |
| compile   |      |
| resources |      |
| install   |      |
| site      |      |
| deploy    |      |
| surefire  |      |
| war       |      |

- **常用命令**

```
# 清除产生的项目
mvn clean

# 编译源代码
mvn compile

# 打包
mvn package

# 只打包不测试（跳过测试）
mvn -dmaven.test.skip=true

# 安装到本地仓库
mvn install

# 源码打包
mvn source:jar
或
mvn source:jar-no-fork
```

##### 5.2 三层架构+MVC

**三层架构：**

- **View（视图层）**：用于接收用户提交请求的代码
- **Service（服务层）**：系统的业务逻辑主要在这里完成
- **DAO（持久层）**：直接操作数据库的代码

为了更好的降低各层间的耦合度，三层架构程序设计中，采用面向抽象编程。即上层对下层的调用，是通过接口实现的。而下层对上层的真正服务提供者，是下层接口的实现类。服务标准（接口）是相同的，服务提供者（实现类）可以更换。这就实现了层间解耦合。

**MVC：**

- **Model**：模型，承载数据，并对用户提交请求进行计算的模块。 其分为两类，一类称为数据承载 Bean，是指实体类 Entity，专门用户承载业务数据的。一类称为业务处理 Bean，是指 Service 或 Dao 对象，专门用于处理用户提交请求。
- **View**：视图，为用户提供使用界面，与用户直接进行交互。
- **Controller**：控制器，用于将用户请求转发给相应的 Model 进行处理，并根据 Model 的计算结果向用户提供相应响应。

**MVC 架构程序的工作流程**

1. 用户通过 View 页面向服务端提出请求，可以是表单请求、超链接请求、AJAX 请求等
2. 服务端 Controller 控制器接收到请求后对请求进行解析，找到相应的 Model 对用户请求进行处理
3. Model 处理后，将处理结果再交给 Controller Controller 在接到处理结果后，根据处理结果找到要作为向客户端发回的响应 View 页面。页面经渲染（数据填充）后，再发送给客户端。

##### 5.3 小知识

[高内聚、低耦合](https://www.bilibili.com/video/av29299488?p=17)

关于技术选型：

[百度指数](http://index.baidu.com/v2/index.html?from=pinzhuan#/)

[社区活跃度](http://github)

##### 5.4 Spring

###### 5.4.1 简介

Spring 是于 2003 年兴起的一个轻量级的 Java 开发框架，它是为了解决企业应用开发的复杂性而创建的。Spring 的核心是控制反转（IoC）和面向切面编程（AOP）。简单来说，Spring 是一个分层的 Java SE/EE full-stack(一站式)轻量级开源框架。

Spring 的主要作用就是为代码“**解耦**”，降低代码间的耦合度。

根据功能的不同，可以将一个系统中的代码分为 主业务逻辑 与 系统级业务逻辑 两类。它们各自具有鲜明的特点：主业务代码间逻辑联系紧密，有具体的专业业务应用场景，复用性相对较低；系统级业务相对功能独立，没有具体的专业业务应用场景，主要是为主业务提供系统级服务，如日志、安全、事务等，复用性强。

Spring 根据代码的功能特点，将降低耦合度的方式分为了两类：**IoC** 与 **AOP**。
IoC 使得主业务在相互调用过程中，不用再自己维护关系了，即不用再自己创建要使用的对象了。而是由 Spring 容器统一管理，自动“注入”。
AOP 使得系统级服务得到了最大复用，且不用再由程序员手工将系统级服务“混杂”到主业务逻辑中了，而是由 Spring 容器统一完成“织入”。

###### 5.4.2 体系

![](E:\程序人生\个人学习笔记\学习笔记图床\spring-overview.png)

###### 5.4.3 特点

- **非侵入式**

所谓非侵入式是指，Spring 框架的 API 不会在业务逻辑上出现，即业务逻辑是 POJO。由于业务逻辑中没有 Spring 的 API，所以业务逻辑可以从 Spring 框架快速的移植到其他框架， 即与环境无关。

- **容器**

Spring 作为一个容器，可以管理对象的生命周期、对象与对象之间的依赖关系。可以通过配置文件，来定义对象，以及设置与其他对象的依赖关系。

- **IoC**

控制反转（Inversion of Control），即创建被调用者的实例不是由调用者完成，而是由 Spring 容器完成，并注入调用者。

当应用了 IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。即，不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。

- **AOP**

面向切面编程（AOP，Aspect Orient Programming），是一种编程思想，是面向对象编程 OOP 的补充。很多框架都实现了对 AOP 编程思想的实现。Spring 也提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如日志和事务管理）进行开发。应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责其它的系统级关注点，例如日志或事务支持。

我们可以把日志、安全、事务管理等服务理解成一个“切面”，那么以前这些服务一直是直接写在业务逻辑的代码当中的，这有两点不好：首先业务逻辑不纯净；其次这些服务被很多业务逻辑反复使用，完全可以剥离出来做到复用。那么 AOP 就是这些问题的解决方案， 可以把这些服务剥离出来形成一个“切面”，以期复用，然后将“切面”动态的“织入”到业务逻辑中，让业务逻辑能够享受到此“切面”的服务。

##### 5.5 JUnit

###### 小知识

**TDD**：测试驱动编程，编程思想。
**DDD**：领域驱动设计

**测试：**

- 单元测试：
  - 白盒测试：能看到完整代码
  - 黑盒测试：没有源码，功能测试
  - 灰盒测试
- 压力测试：并发数问题，能承载多少并发
- 疲劳强度测试：长期稳定运行
- 冒烟测试：对主要流程进行测试，如 支付环节
- 集成测试：完整功能的测试最重要的测试，整体业务流程
- 回归测试：增加一个功能
- 自动化测试：编码，场景设计

###### 5.5.1 注解

| 注解         |                             | 描述                                                         |
| ------------ | --------------------------- | ------------------------------------------------------------ |
| @Test        | public void method()        | 测试注释指示该公共无效方法它所附着可以作为一个测试用例。     |
| @Before      | public void method()        | Before注释表示，该方法必须在类中的每个测试之前执行，以便执行测试某些必要的先决条件。 |
| @BeforeClass | public static void method() | BeforeClass 注释指出这是附着在静态方法必须执行一次并在类的所有测试之前。发生这种情况时一般是测试计算共享配置方法(如连接到数据库)。 |
| @After       | public void method()        | After注释指示，该方法在执行每项测试后执行(如执行每一个测试后重置某些变量，删除临时变量等) |
| @AfterClass  | public static void method() | 当需要执行所有的测试在 JUnit 测试用例类后执行，AfterClass 注解可以使用以清理建立方法，(从数据库如断开连接)。注意：附有此批注(类似于 BeforeClass)的方法必须定义为静态。 |
| @Ignore      | public static void method() | 当想暂时禁用特定的测试执行可以使用忽略注释。每个被注解为 @Ignore 的方法将不被执行。 |

###### 5.5.2 断言（？）

- **什么是断言**

断言是编程术语，表示为一些布尔表达式，程序员相信在程序中的某个特定点该表达式值为真，可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言而在部署时禁用断言。同样，程序投入运行后，最终用户在遇到问题时可以重新启用断言。

使用断言可以创建更稳定、品质更好且 不易于出错的代码。当需要在一个值为 false 时中断当前操作的话，可以使用断言。单元测试必须使用断言（Junit/JunitX）。

- **常用断言方法**

[常用断言方法](https://www.funtl.com/zh/junit/JUnit-断言.html#常用断言方法)

#### 6. Log4j

##### 6.1 简介

一个完整的软件，日志是必不可少的。程序从开发、测试、维护、运行等环节，都需要向控制台或文件等位置输出大量信息。

日志信息根据用途与记录内容的不同，分为 **调试日志**、**运行日志**、**异常日志** 等。

Log4j 的全称为 Log for java，即专门用于 Java 语言的日志记录工具。

##### 6.2 日志级别

- fatal(致命的)
- error
- warn
- info
- debug
- trace(堆栈)

##### 为什么要对日志进行分级？

无论是将日志输出到控制台，还是文件，其输出都会降低程序的运行效率。但由于调试、运行维护的需要，客户的要求等原因，需要进行必要的日志输出。这时就必须要在代码中加入日志输出语句。

这些输出语句若在程序运行时全部执行， 则势必会降低运行效率。而要使其不输出，唯一的办法就是将这些输出语句逐个全部删除。这是个费时费力的过程。

将日志信息进行分级管理，便可方便的控制信息输出内容及输出位置：哪些信息需要输出，哪些信息不需要输出，只需在一个日志输出控制文件中稍加修改即可。而代码中的输出语句不用做任何修改。

从这个角度来说，代码中的日志编写，其实就是写大量的输出语句。只不过，这些输出语句比较特殊，它们具有级别，在程序运行期间不一定被执行。它们的执行是由另一个控制文件控制。

##### 6.3 日志输出控制文件

- **日志输出简介**

Log4j 的日志输出控制文件，主要由三个部分构成：

日志信息的输出位置：控制日志信息将要输出的位置，是控制台还是文件等。
日志信息的输出格式：控制日志信息的显示格式，即以怎样的字符串形式显示。
日志信息的输出级别：控制日志信息的显示内容，即显示哪些级别的日志信息。

有了日志输出控制文件，代码中只要设置好日志信息内容及其级别即可，通过控制文件便可控制这些日志信息的输出。

- **日志属性配置文件**

日志属性文件`log4j.properties`是专门用于控制日志输出的。其主要进行三方面控制：
输出位置：控制日志将要输出的位置，是控制台还是文件等。
输出布局：控制日志信息的显示形式。
输出级别：控制要输出的日志级别。

日志属性文件由两个对象组成：
根日志：Java 代码中的日志记录器，其主要由两个属性构成：日志输出级别与日志附加器。
日志附加器：由日志输出位置定义，由其它很多属性进行修饰，如输出布局、文件位置、文件大小等。

##### 什么是日志附加器？

所谓日志附加器，就是为日志记录器附加上很多其它设置信息。附加器的本质是一个接口，其定义语法为：`log4j.appender.appenderName = 输出位置`

- 常用的附加器实现类
  `org.apache.log4j.ConsoleAppender`：日志输出到控制台
  `org.apache.log4j.FileAppender`：日志输出到文件
  `org.apache.log4j.RollingFileAppender`：当日志文件大小到达指定尺寸的时候将产生一个新的日志文件
  `org.apache.log4j.DailyRollingFileAppender`：每天产生一个日志文件
- **常用布局类型**

`org.apache.log4j.HTMLLayout`：网页布局，以 HTML 表格形式布局
`org.apache.log4j.SimpleLayout`：简单布局，包含日志信息的级别和信息字符串
`org.apache.log4j.PatternLayout`：匹配器布局，可以灵活地指定布局模式。其主要是通过设置 PatternLayout 的 ConversionPattern 属性值来控制具体输出格式的 。

打印参数: Log4J 采用类似 C 语言中的 printf 函数的打印格式格式化日志信息

`%m`：输出代码中指定的消息
`%p`：输出优先级，即 DEBUG，INFO，WARN，ERROR，FATAL
`%c`：输出所属的类目，通常就是所在类的全名
`%t`：输出产生该日志事件的线程名
`%n`：输出一个回车换行符，Windows 平台为 /r/n，Unix 平台为 /n
`%d`：输出日志时间点的日期或时间，默认格式为 ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss , SSS}，输出类似：2002年10月18日 22:10:28,921
`%l`：输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java: 10 )

#### 7. MyBatis

[MyBatis](https://www.funtl.com/zh/mybatis/)

#### 8. Spring的事务管理

[事务管理](https://www.funtl.com/zh/spring-transaction/#本节视频)

